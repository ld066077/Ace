### 无 i 版本     LYX/failed
参数设置（cs）：test2
修改particle.dat  electron charge=1
	问题：balance_N00为负
修改电子charge=-1
eq_ad.in修改回test1
mesh.dat   ionnum=2
wrong set ion1 charge=-1-->1  particle.dat
mesh.dat ionnum修改回1
去除DenN0 = 1.0_dp，TemT0 = 1.0_dp Global.f90
去除DenN0 = 1.0_dp，TemT0 = 1.0_dp  和UpaU0=0.0_dp Global.f90
a=0.60,  R0=1.40                   eq_adhoc.in
a=0.45,R0=1.25
ion charge=2                        particle.dat
ion charge-->1
a=0.75, R0=2 ;c2=3,c3=1,c0=1       eq_adhoc.in
a=0.45,R0=1.25;c2=2.41,c0=0.85     
Bphi0=2
Bphi0-->1.5
ionNum=2                                         mesh.dat
ionNum-->1

密度修改，1+delta n Or DenN0+delta n？for n in0.45-0.6a?  k in 0.45-0.6a


16 TH   maxstep=100000
global DenN0= 1+delta n

r in0.5-0.55   denn0=1+delta n
16 TH   maxstep=100000

### 带 i 版本  LYX/iedition


### wed  LYX/wed
q: c1-c4=0   c2=0.01  c0 =1.5196881463     eq_adhoc.in
r in0.5-0.52   denn0=1+delta n   kr=698.132      Global.f90



### V4.9
c0=1.40
c0=1
	c0=1
	Global.f90   DenN0  DenN0 = 1.0_dp+10e-4 sin(r2pi/(0.15))
c0=1.40

nrx=160
c0 =  1.40
        c1 =  0.00
        c2 =  0.00
        c3 =  0.00
        c4 =  0.00
        if(r.gt.0.45 .and. r.lt.0.6)then
        DenN0 = 1.0_dp+10e-4sin(r2pi/(0.15))
      else
        DenN0 = 1.0_dp
      end if

nrx=80
c0 =  1.40
        c1 =  0.00
        c2 =  0.00
        c3 =  0.00
        c4 =  0.00
        if(r.gt.0.45 .and. r.lt.0.6)then
        DenN0 = 1.0_dp+10e-3sin(r2pi/(0.15))
      else
        DenN0 = 1.0_dp
      end if

### newepsi
VlasovDF.f90
	 !real(dp),parameter :: L_R = 0.45_dp, R_R = 0.60_dp
Global.f90
	grid contains  L_R ,R_R
	if(r.gt.L_R .and. r.lt.R_R)then
        DenN0 = 1.0_dp+1e-4*sin((r-L_R)*2*pi/(R_R-L_R))
      else
        DenN0 = 1.0_dp
      end if

### modified wed /THL8/home/daizl/LYX/modw1114
使用Wolfram Language中的`NIntegrate`函数进行数值积分时，它会自动检测奇点并采取适当的措施来确保积分的准确性和收敛性。因此，在数值上求解含奇点的积分时，并不需要在奇点处单独进行计算，而是依赖于数值积分算法的内部机制来处理这些特殊情况